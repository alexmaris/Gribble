Gribble
=============

Gribble is a simple, Linq enabled ORM that was designed to work with dynamically created tables. It was not meant to be a replacement for a full fledged ORM like NHiberate but to handle a use case that other ORM's could not handle well. 

Here is the skinny:

* Supports most Linq query operators.
* Supports POCO's.
* Simple fluent mapping API (shamelessly ripped off from FluentNHibernate).
* Assign dynamic fields to a dictionary property.
* Only supports SQL Server.
* Create, modify and delete tables, columns and indexes.
* Execute stored procs and map results to entites.
* Additional query operators for copying/syncing data and querying duplicate/distinct records.
* Interfaced based so you can test against in memory collections.
* NHibernate session/transaction integration.
	
Example
------------
    
Let's say we have the following dynamically created table where Id, Street, City, State and Zip are standard columns and all other columns are dynamic (e.g. Code and Active):

    CREATE TABLE Address_F2A74B 
    (
	    Id uniqueidentifier NOT NULL,
	    Street nvarchar(200) NOT NULL,
	    City nvarchar(200) NOT NULL,
	    State nvarchar(200) NOT NULL,
	    Zip nvarchar(200) NOT NULL,
	    Code varchar(3) NOT NULL,
	    Active bit NOT NULL
    )

For this table we create the following entity:

    public class Address 
    {
        public Guid Id { get; set; }
        public string Street { get; set; }
        public string City { get; set; }
        public string State { get; set; }
        public string Zip { get; set; }
        public Dictionary<string, object> Values { get; set; }
    }
    
The Values property will allow us to get and set all non mapped fields (I refer to them as "dynamic" fields in this document). This property must be a Dictionary<string, object> where the key is the name of the field and the value is the value of the field.

We next create a map in the spirit of [James Gregory's FluentNHibernate](http://www.fluentnhibernate.org/):

    public class AddressMap : ClassMap<Address>
    {
        public AddressMap()
        {
            Id(x => x.Id).Column("Id").Generated();
            Map(x => x.Street).Column("Street");
            Map(x => x.City).Column("City");
            Map(x => x.State).Column("State");
            Map(x => x.Zip).Column("Zip");
            Map(x => x.Values).Dynamic();
        }
    }
    
The Gribble fluent mapping works the same as FNH. The Generated() flag tells Gribble that it will need to generate the id. In this case it will generate a Guid COMB. If the id is generated by the database, as in the case of an identity field or default value, this flag should be ommitted. The Dynamic() flag this tells Gribble that the property will be a catch all bag for columns that are not mapped.

Note: Gribble also provides a stock entity (Gribble.Entity<TKey>) and class map (Gribble.IntKeyEntityMap/GuidKeyEntityMap) out of the box that only contains an Id and Values property. This is handy if you need to work with a table that is completely dynamic and do not want to create an entity and map. Table contains static factory methods, discussed next, that omit the mapping and will use the built in one (Table.Create<TKey>(...)).

We create a Table by passing in Gribble.IConnectionManager, an entity map and an optional profiler. You can create a table with the new keyword or one of the static factory methods. There is a connection manager that takes a System.Data.SqlConnection or connection string and one that takes an NHibernate.ISession (When using NHibernate integration). The class map you defined above will also need to be wrapped in an EntityMapping and passed in as well. 

    // Connection string and console profiler
    using (var connectionManager = new ConnectionManager("server=localhost...")) 
    {
        var table = new Table(connectionManager, "Address_F2A74B", new EntityMapping(new AddressMap()), new ConsoleProfiler());
        ...
    }

    // Existing connection
    using (var connection = new SqlConnection("server=localhost...")) 
    {
        connection.Open();
        var connectionManager = new ConnectionManager(connection);
        var table = new Table(connectionManager, "Address_F2A74B", new EntityMapping(new AddressMap()));
        ...
    }

    // NHibernate session
    using (var session = sessionFactory.OpenSession()) 
    {
        var connectionManager = new Gribble.NHibernate.ConnectionManager(session);
        var table = new Table(connectionManager, "Address_F2A74B", new EntityMapping(new AddressMap()));
        ...
    }
    
    // Static factory using built in entity and map. Requires key column name.
    using (var connectionManager = new ConnectionManager("server=localhost...")) 
    {
        var table = Table.Create<Guid>(connectionManager, "Address_F2A74B", "Id");
        ...
    }
    
Now that you have a Table you can query it:

    var results = table.Where(x => x.State == "CO" && x.Values["Active"]).ToList();

Dynamic values can be specified in the Linq query by passing in the name of the column as the key. Most of the query operators are supported including a few additional ones.

You can also get, add, modify, delete and delete many records:
    
    var address = new Address { Street = "123 Rainey Street", ... };
    table.Insert(address);
    Console.WriteLine("Created address with id: {0}", address.Id);

    address = table.Get(address.Id);
    Console.WriteLine("Street is {0}", address.Street);
    
    address.Street = "456 Rainey Street";
    table.Update(address);
    
    table.Delete(adress.Id);
    
    table.Delete(address)
    
    table.Delete(x => x.Values["Code"] == 12345);
    
    table.DeleteMany(x => x.State == "CO" && !x.Values["Active"]);
    
    table.DeleteMany(table.Duplicates(x => x.Values["Code"]));

Distribution
------------

http://nuget.org/List/Packages/gribble  
http://nuget.org/List/Packages/gribble.nhibernate
	
Props
------------

Thanks to [JetBrains](http://www.jetbrains.com/) for providing OSS licenses!